/**
 * Generated by orval v7.13.2 ðŸº
 * Do not edit manually.
 * Chat Api
 * API documentation with JWT Authentication
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import { fetcher } from '../customFetch';
/**
 * Purpose of OTP
 */
export type SendOtpDtoType = (typeof SendOtpDtoType)[keyof typeof SendOtpDtoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SendOtpDtoType = {
  login: 'login',
  signup: 'signup',
} as const;

export interface SendOtpDto {
  /** Phone number with country code */
  phone: string;
  /** Purpose of OTP */
  type: SendOtpDtoType;
}

export type VerifyOtpDtoType = (typeof VerifyOtpDtoType)[keyof typeof VerifyOtpDtoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const VerifyOtpDtoType = {
  login: 'login',
  signup: 'signup',
} as const;

export interface VerifyOtpDto {
  phone: string;
  otp: string;
  type: VerifyOtpDtoType;
}

/**
 * Last seen timestamp (null if online)
 * @nullable
 */
export type UserResponseDtoLastSeenAt = { [key: string]: unknown } | null;

export interface UserResponseDto {
  id: string;
  name: string;
  phone: string;
  email: string;
  isPhoneVerified: boolean;
  /** User profile about/status */
  about: string;
  /** User online status */
  isOnline: boolean;
  /**
   * Last seen timestamp (null if online)
   * @nullable
   */
  lastSeenAt: UserResponseDtoLastSeenAt;
}

export interface VerifyOtpResponse {
  phone: string;
  otpToken: string;
  isNewUser: boolean;
  access_token: string;
  refresh_token: string;
  user: UserResponseDto;
}

export interface CompleteSignupDto {
  /** Phone number that was used to receive OTP */
  phone: string;
  /** Full name of the user */
  name: string;
  /** Email address of the user */
  email: string;
  /** Temporary OTP token obtained from verify-otp */
  otpToken: string;
}

export interface CompleteSignupResponseDto {
  access_token: string;
  refresh_token: string;
  user: UserResponseDto;
}

export interface RefreshTokenDto {
  /** The refresh token obtained during login */
  refresh_token: string;
}

export interface UpdateAboutDto {
  /** User profile status / about text */
  about: string;
}

export interface AddContactDto {
  /** Phone number of the friend you want to add */
  friendPhone: string;
}

/**
 * @nullable
 */
export type ContactChatResponseDtoConversationId = { [key: string]: unknown } | null;

/**
 * @nullable
 */
export type ContactChatResponseDtoLastMessage = { [key: string]: unknown } | null;

/**
 * @nullable
 */
export type ContactChatResponseDtoLastMessageBy = { [key: string]: unknown } | null;

export interface ContactChatResponseDto {
  contactId: string;
  friend: UserResponseDto;
  /** @nullable */
  conversationId: ContactChatResponseDtoConversationId;
  /** @nullable */
  lastMessage: ContactChatResponseDtoLastMessage;
  /** @nullable */
  lastMessageAt: string | null;
  /** @nullable */
  lastMessageBy: ContactChatResponseDtoLastMessageBy;
  lastMessageRead: UserResponseDto[];
  /** Unread messages count */
  unreadCount: number;
}

export interface StartConversationDto {
  /** Friend ID to start chat with */
  friendId: string;
}

export type ConversationParticipantDtoRole = { [key: string]: unknown };

export interface ConversationParticipantDto {
  userId: string;
  role: ConversationParticipantDtoRole;
  joinedAt: string;
}

export interface StartConversationResponseDto {
  id: string;
  isGroup: boolean;
  name: string;
  createdAt: string;
  participants: ConversationParticipantDto[];
}

export interface CreateGroupConversationDto {
  name: string;
  members: string[];
}

export interface ConversationParticipantResponseDto {
  id: string;
  conversationId: string;
  userId: string;
  role: string;
  joinedAt: string;
  user: UserResponseDto;
}

export interface LastMessageReadDto {
  id: string;
  messageId: string;
  userId: string;
  readAt: string;
}

export interface ConversationGroupResponseDto {
  id: string;
  isGroup: boolean;
  name: string;
  createdAt: string;
  participants: ConversationParticipantResponseDto[];
  /** @nullable */
  lastMessage: string | null;
  /** @nullable */
  lastMessageAt: string | null;
  /** @nullable */
  lastMessageBy: string | null;
  lastMessageReads: LastMessageReadDto[];
  unreadCount: number;
}

export interface ConversationResponseDto {
  id: string;
  isGroup: boolean;
  name: string;
  createdAt: string;
  participants: ConversationParticipantResponseDto[];
}

/**
 * Metadata for attached file (image, pdf, etc.)
 */
export type CreateMessageDtoMeta = { [key: string]: unknown };

export interface CreateMessageDto {
  /** ID of the message being replied to */
  replyToId?: string;
  /** ID of the conversation */
  conversationId: string;
  /** Text content of the message */
  content?: string;
  /** Metadata for attached file (image, pdf, etc.) */
  meta?: CreateMessageDtoMeta;
}

export interface MessageMetaDto {
  url: string;
  type: string;
  size: number;
  format?: string;
  publicId?: string;
  fileName?: string;
  fileSize?: string;
  fileType?: string;
}

export type ReplyToMessageDtoType =
  (typeof ReplyToMessageDtoType)[keyof typeof ReplyToMessageDtoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReplyToMessageDtoType = {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE',
  SYSTEM: 'SYSTEM',
} as const;

export interface ReplyToMessageDto {
  id: string;
  content: string;
  type: ReplyToMessageDtoType;
  meta?: MessageMetaDto;
  sender: UserResponseDto;
}

export type MessageResponseDtoType =
  (typeof MessageResponseDtoType)[keyof typeof MessageResponseDtoType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MessageResponseDtoType = {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE',
  SYSTEM: 'SYSTEM',
} as const;

/**
 * @nullable
 */
export type MessageResponseDtoMeta = MessageMetaDto | null;

export interface MessageResponseDto {
  id: string;
  conversationId: string;
  senderId: string;
  content: string;
  type: MessageResponseDtoType;
  /** @nullable */
  meta?: MessageResponseDtoMeta;
  replyToId?: string;
  deletedForAll: boolean;
  createdAt: string;
  sender: UserResponseDto;
  deletions: string[];
  replyTo?: ReplyToMessageDto;
  reads: UserResponseDto[];
}

export interface UploadChatFileDto {
  /** File to upload for chat */
  file: Blob;
}

export interface UploadChatFileResponseDto {
  /** URL of the uploaded file */
  url: string;
  /** Type of the file */
  type: string;
  /** Size of the file in bytes */
  size: number;
  /** File format */
  format: string;
  /** Cloudinary public ID of the file */
  publicId: string;
}

export const appControllerGetHello = (signal?: AbortSignal) => {
  return fetcher<void>({ url: `/`, method: 'GET', signal });
};

export const getAppControllerGetHelloQueryKey = () => {
  return [`/`] as const;
};

export const getAppControllerGetHelloQueryOptions = <
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAppControllerGetHelloQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof appControllerGetHello>>> = ({ signal }) =>
    appControllerGetHello(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof appControllerGetHello>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AppControllerGetHelloQueryResult = NonNullable<
  Awaited<ReturnType<typeof appControllerGetHello>>
>;
export type AppControllerGetHelloQueryError = unknown;

export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appControllerGetHello>>,
          TError,
          Awaited<ReturnType<typeof appControllerGetHello>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAppControllerGetHello<
  TData = Awaited<ReturnType<typeof appControllerGetHello>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appControllerGetHello>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAppControllerGetHelloQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Send OTP to phone number
 */
export const authControllerSendOtp = (sendOtpDto: SendOtpDto, signal?: AbortSignal) => {
  return fetcher<void>({
    url: `/auth/send-otp`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: sendOtpDto,
    signal,
  });
};

export const getAuthControllerSendOtpMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerSendOtp>>,
    TError,
    { data: SendOtpDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerSendOtp>>,
  TError,
  { data: SendOtpDto },
  TContext
> => {
  const mutationKey = ['authControllerSendOtp'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerSendOtp>>,
    { data: SendOtpDto }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerSendOtp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerSendOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerSendOtp>>
>;
export type AuthControllerSendOtpMutationBody = SendOtpDto;
export type AuthControllerSendOtpMutationError = unknown;

/**
 * @summary Send OTP to phone number
 */
export const useAuthControllerSendOtp = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerSendOtp>>,
      TError,
      { data: SendOtpDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerSendOtp>>,
  TError,
  { data: SendOtpDto },
  TContext
> => {
  const mutationOptions = getAuthControllerSendOtpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Verify OTP and login/register user
 */
export const authControllerVerifyOtp = (verifyOtpDto: VerifyOtpDto, signal?: AbortSignal) => {
  return fetcher<VerifyOtpResponse>({
    url: `/auth/verify-otp`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: verifyOtpDto,
    signal,
  });
};

export const getAuthControllerVerifyOtpMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerVerifyOtp>>,
    TError,
    { data: VerifyOtpDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerVerifyOtp>>,
  TError,
  { data: VerifyOtpDto },
  TContext
> => {
  const mutationKey = ['authControllerVerifyOtp'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerVerifyOtp>>,
    { data: VerifyOtpDto }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerVerifyOtp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerVerifyOtpMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerVerifyOtp>>
>;
export type AuthControllerVerifyOtpMutationBody = VerifyOtpDto;
export type AuthControllerVerifyOtpMutationError = unknown;

/**
 * @summary Verify OTP and login/register user
 */
export const useAuthControllerVerifyOtp = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerVerifyOtp>>,
      TError,
      { data: VerifyOtpDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerVerifyOtp>>,
  TError,
  { data: VerifyOtpDto },
  TContext
> => {
  const mutationOptions = getAuthControllerVerifyOtpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Complete signup after OTP verification
 */
export const authControllerCompleteSignup = (
  completeSignupDto: CompleteSignupDto,
  signal?: AbortSignal,
) => {
  return fetcher<CompleteSignupResponseDto>({
    url: `/auth/complete-signup`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: completeSignupDto,
    signal,
  });
};

export const getAuthControllerCompleteSignupMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerCompleteSignup>>,
    TError,
    { data: CompleteSignupDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerCompleteSignup>>,
  TError,
  { data: CompleteSignupDto },
  TContext
> => {
  const mutationKey = ['authControllerCompleteSignup'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerCompleteSignup>>,
    { data: CompleteSignupDto }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerCompleteSignup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerCompleteSignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerCompleteSignup>>
>;
export type AuthControllerCompleteSignupMutationBody = CompleteSignupDto;
export type AuthControllerCompleteSignupMutationError = unknown;

/**
 * @summary Complete signup after OTP verification
 */
export const useAuthControllerCompleteSignup = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerCompleteSignup>>,
      TError,
      { data: CompleteSignupDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerCompleteSignup>>,
  TError,
  { data: CompleteSignupDto },
  TContext
> => {
  const mutationOptions = getAuthControllerCompleteSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Refresh JWT Access Token
 */
export const authControllerRefresh = (refreshTokenDto: RefreshTokenDto, signal?: AbortSignal) => {
  return fetcher<void>({
    url: `/auth/refresh`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: refreshTokenDto,
    signal,
  });
};

export const getAuthControllerRefreshMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerRefresh>>,
    TError,
    { data: RefreshTokenDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerRefresh>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationKey = ['authControllerRefresh'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerRefresh>>,
    { data: RefreshTokenDto }
  > = (props) => {
    const { data } = props ?? {};

    return authControllerRefresh(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerRefreshMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerRefresh>>
>;
export type AuthControllerRefreshMutationBody = RefreshTokenDto;
export type AuthControllerRefreshMutationError = unknown;

/**
 * @summary Refresh JWT Access Token
 */
export const useAuthControllerRefresh = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerRefresh>>,
      TError,
      { data: RefreshTokenDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authControllerRefresh>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationOptions = getAuthControllerRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Logout user (invalidate refresh token)
 */
export const authControllerLogout = (signal?: AbortSignal) => {
  return fetcher<void>({ url: `/auth/logout`, method: 'POST', signal });
};

export const getAuthControllerLogoutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authControllerLogout>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authControllerLogout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['authControllerLogout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authControllerLogout>>,
    void
  > = () => {
    return authControllerLogout();
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthControllerLogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof authControllerLogout>>
>;

export type AuthControllerLogoutMutationError = unknown;

/**
 * @summary Logout user (invalidate refresh token)
 */
export const useAuthControllerLogout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authControllerLogout>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof authControllerLogout>>, TError, void, TContext> => {
  const mutationOptions = getAuthControllerLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all users (requires JWT)
 */
export const userControllerFindAll = (signal?: AbortSignal) => {
  return fetcher<void>({ url: `/user`, method: 'GET', signal });
};

export const getUserControllerFindAllQueryKey = () => {
  return [`/user`] as const;
};

export const getUserControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindAll>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerFindAllQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindAll>>> = ({ signal }) =>
    userControllerFindAll(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerFindAll>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindAll>>
>;
export type UserControllerFindAllQueryError = unknown;

export function useUserControllerFindAll<
  TData = Awaited<ReturnType<typeof userControllerFindAll>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindAll>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindAll<
  TData = Awaited<ReturnType<typeof userControllerFindAll>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindAll>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindAll<
  TData = Awaited<ReturnType<typeof userControllerFindAll>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all users (requires JWT)
 */

export function useUserControllerFindAll<
  TData = Awaited<ReturnType<typeof userControllerFindAll>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerFindAllQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a user by ID (requires JWT)
 */
export const userControllerFindOne = (id: string, signal?: AbortSignal) => {
  return fetcher<void>({ url: `/user/${id}`, method: 'GET', signal });
};

export const getUserControllerFindOneQueryKey = (id?: string) => {
  return [`/user/${id}`] as const;
};

export const getUserControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindOne>>> = ({ signal }) =>
    userControllerFindOne(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerFindOne>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindOne>>
>;
export type UserControllerFindOneQueryError = unknown;

export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindOne>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindOne>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a user by ID (requires JWT)
 */

export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = unknown,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerFindOneQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update user about/status
 */
export const userControllerUpdateAbout = (updateAboutDto: UpdateAboutDto) => {
  return fetcher<void>({
    url: `/user/about`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateAboutDto,
  });
};

export const getUserControllerUpdateAboutMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerUpdateAbout>>,
    TError,
    { data: UpdateAboutDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerUpdateAbout>>,
  TError,
  { data: UpdateAboutDto },
  TContext
> => {
  const mutationKey = ['userControllerUpdateAbout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerUpdateAbout>>,
    { data: UpdateAboutDto }
  > = (props) => {
    const { data } = props ?? {};

    return userControllerUpdateAbout(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerUpdateAboutMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerUpdateAbout>>
>;
export type UserControllerUpdateAboutMutationBody = UpdateAboutDto;
export type UserControllerUpdateAboutMutationError = unknown;

/**
 * @summary Update user about/status
 */
export const useUserControllerUpdateAbout = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userControllerUpdateAbout>>,
      TError,
      { data: UpdateAboutDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof userControllerUpdateAbout>>,
  TError,
  { data: UpdateAboutDto },
  TContext
> => {
  const mutationOptions = getUserControllerUpdateAboutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create a new Contact (requires authentication)
 */
export const contactControllerAddContact = (addContactDto: AddContactDto, signal?: AbortSignal) => {
  return fetcher<void>({
    url: `/contacts/add`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: addContactDto,
    signal,
  });
};

export const getContactControllerAddContactMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof contactControllerAddContact>>,
    TError,
    { data: AddContactDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof contactControllerAddContact>>,
  TError,
  { data: AddContactDto },
  TContext
> => {
  const mutationKey = ['contactControllerAddContact'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof contactControllerAddContact>>,
    { data: AddContactDto }
  > = (props) => {
    const { data } = props ?? {};

    return contactControllerAddContact(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ContactControllerAddContactMutationResult = NonNullable<
  Awaited<ReturnType<typeof contactControllerAddContact>>
>;
export type ContactControllerAddContactMutationBody = AddContactDto;
export type ContactControllerAddContactMutationError = unknown;

/**
 * @summary Create a new Contact (requires authentication)
 */
export const useContactControllerAddContact = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof contactControllerAddContact>>,
      TError,
      { data: AddContactDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof contactControllerAddContact>>,
  TError,
  { data: AddContactDto },
  TContext
> => {
  const mutationOptions = getContactControllerAddContactMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all my contacts (requires authentication)
 */
export const contactControllerGetAllContacts = (signal?: AbortSignal) => {
  return fetcher<ContactChatResponseDto[]>({ url: `/contacts`, method: 'GET', signal });
};

export const getContactControllerGetAllContactsQueryKey = () => {
  return [`/contacts`] as const;
};

export const getContactControllerGetAllContactsQueryOptions = <
  TData = Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetAllContacts>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContactControllerGetAllContactsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contactControllerGetAllContacts>>> = ({
    signal,
  }) => contactControllerGetAllContacts(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactControllerGetAllContactsQueryResult = NonNullable<
  Awaited<ReturnType<typeof contactControllerGetAllContacts>>
>;
export type ContactControllerGetAllContactsQueryError = unknown;

export function useContactControllerGetAllContacts<
  TData = Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetAllContacts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
          TError,
          Awaited<ReturnType<typeof contactControllerGetAllContacts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useContactControllerGetAllContacts<
  TData = Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetAllContacts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
          TError,
          Awaited<ReturnType<typeof contactControllerGetAllContacts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useContactControllerGetAllContacts<
  TData = Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetAllContacts>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all my contacts (requires authentication)
 */

export function useContactControllerGetAllContacts<
  TData = Awaited<ReturnType<typeof contactControllerGetAllContacts>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetAllContacts>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getContactControllerGetAllContactsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get  contact By Id (requires authentication)
 */
export const contactControllerGetContact = (contactId: string, signal?: AbortSignal) => {
  return fetcher<ContactChatResponseDto>({ url: `/contacts/${contactId}`, method: 'GET', signal });
};

export const getContactControllerGetContactQueryKey = (contactId?: string) => {
  return [`/contacts/${contactId}`] as const;
};

export const getContactControllerGetContactQueryOptions = <
  TData = Awaited<ReturnType<typeof contactControllerGetContact>>,
  TError = unknown,
>(
  contactId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetContact>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getContactControllerGetContactQueryKey(contactId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof contactControllerGetContact>>> = ({
    signal,
  }) => contactControllerGetContact(contactId, signal);

  return { queryKey, queryFn, enabled: !!contactId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof contactControllerGetContact>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactControllerGetContactQueryResult = NonNullable<
  Awaited<ReturnType<typeof contactControllerGetContact>>
>;
export type ContactControllerGetContactQueryError = unknown;

export function useContactControllerGetContact<
  TData = Awaited<ReturnType<typeof contactControllerGetContact>>,
  TError = unknown,
>(
  contactId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetContact>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof contactControllerGetContact>>,
          TError,
          Awaited<ReturnType<typeof contactControllerGetContact>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useContactControllerGetContact<
  TData = Awaited<ReturnType<typeof contactControllerGetContact>>,
  TError = unknown,
>(
  contactId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetContact>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof contactControllerGetContact>>,
          TError,
          Awaited<ReturnType<typeof contactControllerGetContact>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useContactControllerGetContact<
  TData = Awaited<ReturnType<typeof contactControllerGetContact>>,
  TError = unknown,
>(
  contactId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetContact>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get  contact By Id (requires authentication)
 */

export function useContactControllerGetContact<
  TData = Awaited<ReturnType<typeof contactControllerGetContact>>,
  TError = unknown,
>(
  contactId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof contactControllerGetContact>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getContactControllerGetContactQueryOptions(contactId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Start a 1:1 conversation with a contact
 */
export const conversationControllerStartConversation = (
  startConversationDto: StartConversationDto,
  signal?: AbortSignal,
) => {
  return fetcher<StartConversationResponseDto>({
    url: `/conversation/start`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: startConversationDto,
    signal,
  });
};

export const getConversationControllerStartConversationMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof conversationControllerStartConversation>>,
    TError,
    { data: StartConversationDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof conversationControllerStartConversation>>,
  TError,
  { data: StartConversationDto },
  TContext
> => {
  const mutationKey = ['conversationControllerStartConversation'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof conversationControllerStartConversation>>,
    { data: StartConversationDto }
  > = (props) => {
    const { data } = props ?? {};

    return conversationControllerStartConversation(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConversationControllerStartConversationMutationResult = NonNullable<
  Awaited<ReturnType<typeof conversationControllerStartConversation>>
>;
export type ConversationControllerStartConversationMutationBody = StartConversationDto;
export type ConversationControllerStartConversationMutationError = unknown;

/**
 * @summary Start a 1:1 conversation with a contact
 */
export const useConversationControllerStartConversation = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof conversationControllerStartConversation>>,
      TError,
      { data: StartConversationDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof conversationControllerStartConversation>>,
  TError,
  { data: StartConversationDto },
  TContext
> => {
  const mutationOptions = getConversationControllerStartConversationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create a group conversation
 */
export const conversationControllerCreateGroup = (
  createGroupConversationDto: CreateGroupConversationDto,
  signal?: AbortSignal,
) => {
  return fetcher<void>({
    url: `/conversation/group`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createGroupConversationDto,
    signal,
  });
};

export const getConversationControllerCreateGroupMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof conversationControllerCreateGroup>>,
    TError,
    { data: CreateGroupConversationDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof conversationControllerCreateGroup>>,
  TError,
  { data: CreateGroupConversationDto },
  TContext
> => {
  const mutationKey = ['conversationControllerCreateGroup'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof conversationControllerCreateGroup>>,
    { data: CreateGroupConversationDto }
  > = (props) => {
    const { data } = props ?? {};

    return conversationControllerCreateGroup(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConversationControllerCreateGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof conversationControllerCreateGroup>>
>;
export type ConversationControllerCreateGroupMutationBody = CreateGroupConversationDto;
export type ConversationControllerCreateGroupMutationError = unknown;

/**
 * @summary Create a group conversation
 */
export const useConversationControllerCreateGroup = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof conversationControllerCreateGroup>>,
      TError,
      { data: CreateGroupConversationDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof conversationControllerCreateGroup>>,
  TError,
  { data: CreateGroupConversationDto },
  TContext
> => {
  const mutationOptions = getConversationControllerCreateGroupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary List all groups of the logged-in user
 */
export const conversationControllerGetMyGroups = (signal?: AbortSignal) => {
  return fetcher<ConversationGroupResponseDto[]>({
    url: `/conversation/groups`,
    method: 'GET',
    signal,
  });
};

export const getConversationControllerGetMyGroupsQueryKey = () => {
  return [`/conversation/groups`] as const;
};

export const getConversationControllerGetMyGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof conversationControllerGetMyGroups>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getConversationControllerGetMyGroupsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof conversationControllerGetMyGroups>>> = ({
    signal,
  }) => conversationControllerGetMyGroups(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConversationControllerGetMyGroupsQueryResult = NonNullable<
  Awaited<ReturnType<typeof conversationControllerGetMyGroups>>
>;
export type ConversationControllerGetMyGroupsQueryError = unknown;

export function useConversationControllerGetMyGroups<
  TData = Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof conversationControllerGetMyGroups>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
          TError,
          Awaited<ReturnType<typeof conversationControllerGetMyGroups>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerGetMyGroups<
  TData = Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof conversationControllerGetMyGroups>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
          TError,
          Awaited<ReturnType<typeof conversationControllerGetMyGroups>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerGetMyGroups<
  TData = Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof conversationControllerGetMyGroups>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List all groups of the logged-in user
 */

export function useConversationControllerGetMyGroups<
  TData = Awaited<ReturnType<typeof conversationControllerGetMyGroups>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof conversationControllerGetMyGroups>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getConversationControllerGetMyGroupsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get conversation by ID (1:1 excludes logged-in user from participants)
 */
export const conversationControllerGetConversationById = (
  conversationId: string,
  signal?: AbortSignal,
) => {
  return fetcher<ConversationResponseDto>({
    url: `/conversation/${conversationId}`,
    method: 'GET',
    signal,
  });
};

export const getConversationControllerGetConversationByIdQueryKey = (conversationId?: string) => {
  return [`/conversation/${conversationId}`] as const;
};

export const getConversationControllerGetConversationByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getConversationControllerGetConversationByIdQueryKey(conversationId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof conversationControllerGetConversationById>>
  > = ({ signal }) => conversationControllerGetConversationById(conversationId, signal);

  return { queryKey, queryFn, enabled: !!conversationId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ConversationControllerGetConversationByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof conversationControllerGetConversationById>>
>;
export type ConversationControllerGetConversationByIdQueryError = unknown;

export function useConversationControllerGetConversationById<
  TData = Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
  TError = unknown,
>(
  conversationId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
          TError,
          Awaited<ReturnType<typeof conversationControllerGetConversationById>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerGetConversationById<
  TData = Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
          TError,
          Awaited<ReturnType<typeof conversationControllerGetConversationById>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useConversationControllerGetConversationById<
  TData = Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get conversation by ID (1:1 excludes logged-in user from participants)
 */

export function useConversationControllerGetConversationById<
  TData = Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof conversationControllerGetConversationById>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getConversationControllerGetConversationByIdQueryOptions(
    conversationId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Send a message via REST (fallback if WS fails)
 */
export const messageControllerSendMessage = (
  createMessageDto: CreateMessageDto,
  signal?: AbortSignal,
) => {
  return fetcher<void>({
    url: `/message/send`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createMessageDto,
    signal,
  });
};

export const getMessageControllerSendMessageMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof messageControllerSendMessage>>,
    TError,
    { data: CreateMessageDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof messageControllerSendMessage>>,
  TError,
  { data: CreateMessageDto },
  TContext
> => {
  const mutationKey = ['messageControllerSendMessage'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof messageControllerSendMessage>>,
    { data: CreateMessageDto }
  > = (props) => {
    const { data } = props ?? {};

    return messageControllerSendMessage(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type MessageControllerSendMessageMutationResult = NonNullable<
  Awaited<ReturnType<typeof messageControllerSendMessage>>
>;
export type MessageControllerSendMessageMutationBody = CreateMessageDto;
export type MessageControllerSendMessageMutationError = unknown;

/**
 * @summary Send a message via REST (fallback if WS fails)
 */
export const useMessageControllerSendMessage = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof messageControllerSendMessage>>,
      TError,
      { data: CreateMessageDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof messageControllerSendMessage>>,
  TError,
  { data: CreateMessageDto },
  TContext
> => {
  const mutationOptions = getMessageControllerSendMessageMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get all messages of a conversation
 */
export const messageControllerGetMessages = (conversationId: string, signal?: AbortSignal) => {
  return fetcher<MessageResponseDto[]>({
    url: `/message/${conversationId}`,
    method: 'GET',
    signal,
  });
};

export const getMessageControllerGetMessagesQueryKey = (conversationId?: string) => {
  return [`/message/${conversationId}`] as const;
};

export const getMessageControllerGetMessagesQueryOptions = <
  TData = Awaited<ReturnType<typeof messageControllerGetMessages>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof messageControllerGetMessages>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMessageControllerGetMessagesQueryKey(conversationId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof messageControllerGetMessages>>> = ({
    signal,
  }) => messageControllerGetMessages(conversationId, signal);

  return { queryKey, queryFn, enabled: !!conversationId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof messageControllerGetMessages>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MessageControllerGetMessagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof messageControllerGetMessages>>
>;
export type MessageControllerGetMessagesQueryError = unknown;

export function useMessageControllerGetMessages<
  TData = Awaited<ReturnType<typeof messageControllerGetMessages>>,
  TError = unknown,
>(
  conversationId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof messageControllerGetMessages>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messageControllerGetMessages>>,
          TError,
          Awaited<ReturnType<typeof messageControllerGetMessages>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMessageControllerGetMessages<
  TData = Awaited<ReturnType<typeof messageControllerGetMessages>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof messageControllerGetMessages>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messageControllerGetMessages>>,
          TError,
          Awaited<ReturnType<typeof messageControllerGetMessages>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMessageControllerGetMessages<
  TData = Awaited<ReturnType<typeof messageControllerGetMessages>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof messageControllerGetMessages>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all messages of a conversation
 */

export function useMessageControllerGetMessages<
  TData = Awaited<ReturnType<typeof messageControllerGetMessages>>,
  TError = unknown,
>(
  conversationId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof messageControllerGetMessages>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMessageControllerGetMessagesQueryOptions(conversationId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Mark all messages in a conversation as read
 */
export const messageControllerMarkAsRead = (conversationId: string, signal?: AbortSignal) => {
  return fetcher<void>({ url: `/message/read/${conversationId}`, method: 'POST', signal });
};

export const getMessageControllerMarkAsReadMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof messageControllerMarkAsRead>>,
    TError,
    { conversationId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof messageControllerMarkAsRead>>,
  TError,
  { conversationId: string },
  TContext
> => {
  const mutationKey = ['messageControllerMarkAsRead'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof messageControllerMarkAsRead>>,
    { conversationId: string }
  > = (props) => {
    const { conversationId } = props ?? {};

    return messageControllerMarkAsRead(conversationId);
  };

  return { mutationFn, ...mutationOptions };
};

export type MessageControllerMarkAsReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof messageControllerMarkAsRead>>
>;

export type MessageControllerMarkAsReadMutationError = unknown;

/**
 * @summary Mark all messages in a conversation as read
 */
export const useMessageControllerMarkAsRead = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof messageControllerMarkAsRead>>,
      TError,
      { conversationId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof messageControllerMarkAsRead>>,
  TError,
  { conversationId: string },
  TContext
> => {
  const mutationOptions = getMessageControllerMarkAsReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const messageControllerGetUnreadByConversation = (signal?: AbortSignal) => {
  return fetcher<void>({
    url: `/message/unread/total-count/by-conversation`,
    method: 'GET',
    signal,
  });
};

export const getMessageControllerGetUnreadByConversationQueryKey = () => {
  return [`/message/unread/total-count/by-conversation`] as const;
};

export const getMessageControllerGetUnreadByConversationQueryOptions = <
  TData = Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMessageControllerGetUnreadByConversationQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>
  > = ({ signal }) => messageControllerGetUnreadByConversation(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MessageControllerGetUnreadByConversationQueryResult = NonNullable<
  Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>
>;
export type MessageControllerGetUnreadByConversationQueryError = unknown;

export function useMessageControllerGetUnreadByConversation<
  TData = Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
          TError,
          Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMessageControllerGetUnreadByConversation<
  TData = Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
          TError,
          Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMessageControllerGetUnreadByConversation<
  TData = Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMessageControllerGetUnreadByConversation<
  TData = Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof messageControllerGetUnreadByConversation>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMessageControllerGetUnreadByConversationQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Delete a message for everyone (sender only)
 */
export const messageControllerDeleteForEveryone = (messageId: string) => {
  return fetcher<void>({ url: `/message/${messageId}/delete-for-all`, method: 'DELETE' });
};

export const getMessageControllerDeleteForEveryoneMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof messageControllerDeleteForEveryone>>,
    TError,
    { messageId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof messageControllerDeleteForEveryone>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationKey = ['messageControllerDeleteForEveryone'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof messageControllerDeleteForEveryone>>,
    { messageId: string }
  > = (props) => {
    const { messageId } = props ?? {};

    return messageControllerDeleteForEveryone(messageId);
  };

  return { mutationFn, ...mutationOptions };
};

export type MessageControllerDeleteForEveryoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof messageControllerDeleteForEveryone>>
>;

export type MessageControllerDeleteForEveryoneMutationError = unknown;

/**
 * @summary Delete a message for everyone (sender only)
 */
export const useMessageControllerDeleteForEveryone = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof messageControllerDeleteForEveryone>>,
      TError,
      { messageId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof messageControllerDeleteForEveryone>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationOptions = getMessageControllerDeleteForEveryoneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a message for me only (sender or receiver)
 */
export const messageControllerDeleteForMe = (messageId: string) => {
  return fetcher<void>({ url: `/message/${messageId}/delete-for-me`, method: 'DELETE' });
};

export const getMessageControllerDeleteForMeMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof messageControllerDeleteForMe>>,
    TError,
    { messageId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof messageControllerDeleteForMe>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationKey = ['messageControllerDeleteForMe'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof messageControllerDeleteForMe>>,
    { messageId: string }
  > = (props) => {
    const { messageId } = props ?? {};

    return messageControllerDeleteForMe(messageId);
  };

  return { mutationFn, ...mutationOptions };
};

export type MessageControllerDeleteForMeMutationResult = NonNullable<
  Awaited<ReturnType<typeof messageControllerDeleteForMe>>
>;

export type MessageControllerDeleteForMeMutationError = unknown;

/**
 * @summary Delete a message for me only (sender or receiver)
 */
export const useMessageControllerDeleteForMe = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof messageControllerDeleteForMe>>,
      TError,
      { messageId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof messageControllerDeleteForMe>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationOptions = getMessageControllerDeleteForMeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Upload a file for chat
 */
export const uploadControllerUploadChatFile = (
  uploadChatFileDto: UploadChatFileDto,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`file`, uploadChatFileDto.file);

  return fetcher<UploadChatFileResponseDto>({
    url: `/upload/chat-file`,
    method: 'POST',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData,
    signal,
  });
};

export const getUploadControllerUploadChatFileMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadControllerUploadChatFile>>,
    TError,
    { data: UploadChatFileDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadControllerUploadChatFile>>,
  TError,
  { data: UploadChatFileDto },
  TContext
> => {
  const mutationKey = ['uploadControllerUploadChatFile'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadControllerUploadChatFile>>,
    { data: UploadChatFileDto }
  > = (props) => {
    const { data } = props ?? {};

    return uploadControllerUploadChatFile(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadControllerUploadChatFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadControllerUploadChatFile>>
>;
export type UploadControllerUploadChatFileMutationBody = UploadChatFileDto;
export type UploadControllerUploadChatFileMutationError = unknown;

/**
 * @summary Upload a file for chat
 */
export const useUploadControllerUploadChatFile = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadControllerUploadChatFile>>,
      TError,
      { data: UploadChatFileDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadControllerUploadChatFile>>,
  TError,
  { data: UploadChatFileDto },
  TContext
> => {
  const mutationOptions = getUploadControllerUploadChatFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
